-# Modifying data

We know how to fetch the data. But a database is useless without ability of
writing data. In this chapter, we will learn about writing data. We will
address database command, table command, and then document command
in this chapter.

# Database

All commands on database levels start at the top namespace `r` since they are
like genesis item in any database system. Let's start out journey by creating
a database. Remember, we need a database to hold everything.

## Create

Very simple. With example, you will get it easily.

    //Create database
    r.dbCreate("db1")
    #=>
    {
    "config_changes": [
    {
    "new_val": {
    "id":  "5e4a85fa-d867-4a93-aa01-2d08ed6f0b14" ,
    "name":  "db1"
    } ,
    "old_val": null
    }
    ] ,
    "dbs_created": 1
    }

If creating succesfully, we get back the object with `created` is always *1*.
**config_changes** will have **new_val** field is the database's config value.
**old_val** is always *null* becase this is a new database. **config value**
is the configuration for an individual database or table. What is the 
configuration? Usually, when we create any object in RethinkDB (a database, 
a table) we can pass a list of option to that creating command. That option
has to be stored somewhere and we should have ability to read it back.
For a database, configuration is just its name and its id. That's why you see
the id and name are returned in above query. We will learn more about this
configuration very quick in this chapter.


We can confirm by listing what we have:

    r.dbList()
    #=>
    [
    "foodb" ,
    "rethinkdb" ,
    "superheroes" ,
    "test"
    ]

Notice a special database call ***rethinkdb***. This is a special database that
is created by RethinkDB to hold meta data, configuration. It's very similar to
**mysql** database in a MySQL server. Remember the configuration of `dbCreate`
function? Those configuration is stored in table `db_config` inside this
database `rethinkdb`.


## Drop

So we got the default test and db1 is what we just have. Since we don't use db1,
let's delete it to keep it clean. 

    r.dbDrop('db1')
    #=>
    {
    "config_changes": [
    {
    "new_val": null ,
    "old_val": {
    "id":  "5e4a85fa-d867-4a93-aa01-2d08ed6f0b14" ,
    "name":  "db1"
    }
    }
    ] ,
    "dbs_dropped": 1 ,
    "tables_dropped": 0
    }

Very similar with `dbCreate` but in an opposite way. Now `new_val` is **null**
because the database is no longer existed. **old_val** is the id and name of
old database, or the old configuration of database. 

# Table

Tables have to sit inside a database, therefore, all table commands have to call
on a database. When you don't explicit specify a database to run on with `r.db`,
the current database will be the base for table manipulation.

## Create

The syntax to create a table is

    db.tableCreate(tableName[, options])

The second parameter is optional. This is what we consider configuration for
a table. It's similar to database configuration. But table configuration is
much richer. Some important ones are:

*primaryKey

: the name of primary key. As I mentioned before, default name of primary key is
**id**. Using this option, you can change that default behavior like we used
`uuid` with our input_polls table.

*durability

: accept value of *soft* or *hard*. *soft* means the writes will be
acknowledged by server immdediately, and data will be flushed to disk in the
background. If that flushing fail, we may not know. The default behaviour is
to acknowledge after data is written to disk. That means *hard*. It's default
because it's much safety.
When we don't need the data to be consitent, such as writing a cache, or an
unimportant log, we should set durability to soft to speed up the writing.
However, for any important, serious data, keep it default.

## Drop

To list what table we have, call `tableList()`. To get rid of the table, use
`*tableDrop(tablename)*`.

    r.tableList()
    //=>
    [
        "county_stats" ,
        "input_polls"
    ]

    r.tableCreate('foo')
    //=>
    {
      "created": 1
    }    
    r.tableCreate('foo2', {durability: 'soft'})
    //=>
    {
      "created": 1
    }

    r.tableList()
    //=>
    [
      "foo2" ,
      "county_stats" ,
      "input_polls" ,
      "foo"
    ] 
    r.tableDrop('foo') 
    //=>
    {
      "dropped": 1
    }
    r.tableDrop('foo2') 
    //=>
    {
      "dropped": 1
    }
    r.tableList()
    //=>
    [
        "county_stats" ,
        "input_polls"
    ]

Notice how RethinkDB returns a consitent JSON schema for database and table
creating, droping with `created`, `dropped` field. 

# System table

Usually a database server have to keep some meta data, or configuration
information somewhere else. In case of RethinkDB, it stores those data in
**rethinkdb** data. Let's discover this database: 

    r.db("rethinkdb").tableList()
    [
    "cluster_config" ,
    "current_issues" ,
    "db_config" ,
    "jobs" ,
    "logs" ,
    "server_config" ,
    "server_status" ,
    "stats" ,
    "table_config" ,
    "table_status"
    ]

The name of each table should suggest what it contains. Let's inspect **server_config**

    r.db("rethinkdb").table("server_config")
    //=>
    {
    "cache_size_mb":  "auto" ,
    "id":  "fdc5dade-2f0c-498f-8c4b-59ad0d976471" ,
    "name":  "Vinh_local_u27" ,
    "tags": [
    "default"
    ]
    }

Let's change our server name:

  r.db("rethinkdb").table("server_config")
    .get("fdc5dade-2f0c-498f-8c4b-59ad0d976471")
    .update({name: "SimplyRethinkDB"})

You will notice that the Admin UI will change the server name:

![Server name changes to SimplyRethinkDB](images/chapter4/server_name.png)

By modifying those table, we change the configuration of our server. We can get
RethinkDB version by querying `server_status`.

    r.db("rethinkdb").table("server_status")("process")("version")

In other world, those system table refelects information related to how the
system operates. We can query to fetch or modify system information.

We can get configuration that we set when creating table with `tableCreate` of
any table:

    r.db("rethinkdb").table("table_config")
    //=>
    {
    "db":  "foodb" ,
    "durability":  "hard" ,
    "id":  "2e41fc0b-ea5e-4460-bd3b-5d33a5ec49af" ,
    "name":  "health_effects" ,
    "primary_key":  "id" ,
    "shards": [
    {
    "primary_replica":  "SimplyRethinkDB" ,
    "replicas": [
    "SimplyRethinkDB"
    ]
    }
    ] ,
    "write_acks":  "majority"
    } {
    "db":  "foodb" ,
    "durability":  "hard" ,
    "id":  "3fbf59ad-35df-445c-9fa9-be19071d38d7" ,
    "name":  "compounds_flavors" ,
    "primary_key":  "id" ,
    "shards": [
    {
    "primary_replica":  "SimplyRethinkDB" ,
    "replicas": [
    "SimplyRethinkDB"
    ]
    }
    ] ,
    "write_acks":  "majority"
    }

Looking at the above result, we can see that table `health_effects` of database
`foodb` has **primary_key** is **id**, and **write_acks** is **majority**.

You can have more fun and some deep understanding under the hood by inspecting
those tables.

# Document

After creating database and creating table, we can start inserting document into
table.

## Insert

As you can guess, we will start from the database, chain the table, and use
`*insert*` method to insert a document into the table. Eg

    r.db('test').table('input_polls').insert({
      id: 'foo',
      Day: 120,
      Date: 'May 2',
      Dem: '49'
    })
    
    #=>
    {
      "deleted": 0 ,
      "errors": 0 ,
      "generated_keys": [
      "13556cd8-034c-4c0e-91c0-666230740121"
      ] ,
      "inserted": 1 ,
      "replaced": 0 ,
      "skipped": 0 ,
      "unchanged": 0
    }

The return object contains the following attributes: 

inserted
: the number of documents that were succesfully inserted.

replaced
: the number of documents that were updated when upsert is used.

unchanged
: the number of documents that would have been modified, except that the new value was the same as the old value when doing an upsert.

errors
: the number of errors encountered while performing the insert.

first_error
: If errors were encountered, contains the text of the first error.

deleted, skipped
: 0 for an insert operation.

generated_keys
: a list of generated primary keys in case the primary keys for some documents were missing (capped to 100000).

warnings
: if the field generated_keys is truncated, you will get the warning: "Too many generated keys (<X>), array truncated to 100000.".
old_val
: if returnVals is set to true, contains null.
new_val
: if returnVals is set to true, contains the inserted/updated document.

Notice the generated_keys. If you insert a document without set a value for
primary key, whose field name is `*id*` by default, RethinkDB will generate an
UUID[^uuid] for it and return here.

[^uuid]: http://en.wikipedia.org/wiki/Universally_unique_identifier

With our example, we can retreive back the document again.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
    #=>
    {
        "Date":  "May 2" ,
        "Day": 120 ,
        "Dem":  "49" ,
        "id":  "foo" ,
        "uuid":  "13556cd8-034c-4c0e-91c0-666230740121"
    }

Notice the `*uuid*` field? Our table has primary field is `*uuid*` and its value
is set automatically by RethinkDB. 



### Multi insert

If you have a large data set, you may want to do a batch insert.

@TODO
example batch insert

### Effect of **durability**

Let's see the difference of **durability**. We will insert a big document.

First, I will create a temporary table
    r.tableCreate("git")

Then insert data, to have a big amount of data. I use `http`, which is a
command that fetch external JSON data.

    r.table('git').insert(
      r.http('https://api.github.com/repos/rethinkdb/rethinkdb/stargazers')),
      {durability:soft}
    )
    Executed in 773ms. 1 row returned

Now, if I turn on **durability**.

    r.table('git').insert(
      r.http('https://api.github.com/repos/rethinkdb/rethinkdb/stargazers')),
      {durability:soft}
    )
    Executed in 1.18s. 1 row returned


## Update

To make it easier, you can think of updating like selecting data, then change
their value. We chain `update` method from a selection to update its data.

Think of modification is like a transform process where you get a list of document(one or many),
then transform by adding fields, rewrite value for some fields. By that definition, it 
doesn't matter if you update one document, or many document. As long as you have an array, or
a stream of data, you can update them all. 

For example, to update an attribute for a single element

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
          'Dem': 120
      })
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0
    }
     

RethinkDB returns an object for the updating result. We can look into `replaced`
field to see if the data is actually updated. If we re-run the above command,
nothing is replaced and we will got 1 `unchanged`.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
          'Dem': 120
      })
    //=>{

      "deleted": 0 ,
      "errors": 0 ,
      "inserted": 0 ,
      "replaced": 1 ,
      "skipped": 0 ,
      "unchanged": 0

    }

That's just how awesome RethinkDB is. All query result is very verbose. 

To add a new field to an exsited document, we just need to set its value.
    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
          'authors': ['foo']
      })
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }
    //Verify
    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
    #=>
    {

        "Date": "May 2" ,
        "Day": 120 ,
        "Dem": 120 ,
        "New Value": 1 ,
        "authors": [
            "foo"
        ] ,
        "id": "foo" ,
        "uuid": "13556cd8-034c-4c0e-91c0-666230740121"

    }

The value of the updated field, as you can see is a single value. In practice,
you usually want the updated value is returned value from other ReQL expression.
So how do we do that? Let's move to next section.

### Update data for complex field

Now, we got `authors` is an array with only one value of foo. How do we add more
data into its. We can pass an value to the `update`. A naive way, we have to know
the current value, and append a new element. That's just not so efficient
because the array can be big. What we should do is to say: *Hey, let append this value
into the `authors` array*. We can do that by using manipulation document method.
`r.row` is a special method returns the currently visited document. By using it,
we can get the value of field we want.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
    		authors: r.row("authors").append('bar')
			})
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }

However, if `authors` field isn't existed yet, an error will be thrown out. To avoid
that, we can tell RethinkDB to set and use a default value when the field isn't
existed.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
    		lol_authors: r.row("lol_authors").append('bar').default([])
			})
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }

By calling `default`, we can set an default value for the field. In our case, we
use an empty array [] as a default value. 

`append` is a method to manipulation. Besides `append` we can also use
`prepend`. It adds a new element to an array but at the bottom. 

Take another example, we want to count how many time the input_polls is viewed.
We increased its `views` field for one. 


    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
        views: r.row('views').add(1)
			})
    //=>
    {

        "deleted": 0 ,
        "errors": 1 ,
        "first_error": "No attribute `views` in object: { "Date": "May 2", "Day": 120, "Dem": 120, "New Value": 1, "authors": ["foo"], "id": "foo", "lol_author": [], "uuid": "13556cd8-034c-4c0e-91c0-666230740121" }" ,
        "inserted": 0 ,
        "replaced": 0 ,
        "skipped": 0 ,
        "unchanged": 0

    } 

Oops, we got an error here because the *views* field has not existed. Let's set
a default value for 1.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
        views: r.row('views').add(1).default(1)
			})
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }

You can actually use `add` on string, numeric, array fields too. 

Now we know how to work with an array as value of a field and how to work with an
object as a value of a field. Considering that we have this:


    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
        reviewer: {name: 'Vinh', age: 27}
      })
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }

    
The `reviewer` field is an object now. Then we want to add a new field `state` to `reviewer` to denote the `state` of reviewer. We can not use `append` or `add` on an object. We have to merge current document with something new.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
        reviewer: r.row('reviewer').merge({'state': 'CA'})
      })
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }
 
Same as `append`, you can also use `default`:

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
        reviewer: r.row('reviewer').merge({'state': 'CA'}).default({})
      })
 
Since we are working with an object, we set its default value to `{}`. `merge`
overide existed key with new value in the object you are passing, or create new
key from the passing object.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
        reviewer: r.row('reviewer').merge({'age': 25, 'state': 'CA'}).default({})
      })
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }
    //Select it again
    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
    //=>
    {

        "Date": "May 2" ,
        "Day": 120 ,
        "Dem": 120 ,
        "New Value": 1 ,
        "authors": [
            "foo" ,
            "bar"
        ] ,
        "id": "foo-bar" ,
        "reviewer": {
            "age": 25 ,
            "name": "Vinh" ,
            "state": "CA"
        } ,
        "type": "normal" ,
        "uuid": "13556cd8-034c-4c0e-91c0-666230740121" ,
        "views": 100

    }

### Update multiple documents

Instead of select a single document and update one by one, you can update a
bunch of documents by calling `update` on a table or a stream, a selection.
    
    r.table.filter(r.row('Day').gt(1) && r.row('Day').lt(90))
      .update({quarter: 1})
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 55 ,
        "skipped": 0 ,
        "unchanged": 0
    }

### ReQL inside the updated object

As you notice, we not only pass value into an updated object, but also passing
ReQL into updated object. As long as it can be evaluated like:

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
        views: r.row('views').add(1).default(1)
			})

However, this updating method has some limit with `r.row`. It cannot be called on
nested query. 

Example, for each polls, we want to count how many poll on same `Date`, and
storing the counting result into a field call `same_day_count` to avoid counting
everytime we need it. We use another query inside `update`, and reference to
`r.row` to get current document for comparison. 

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
        same_day_count: r.table('input_polls')('Date').count(r.row('Date'))
      })
    //=>
    RqlCompileError: Cannot use r.row in nested queries.  Use functions instead in:
    r.table("input_polls").get("13556cd8-034c-4c0e-91c0-666230740121").update({same_day_count: r.table("input_polls")("Date").count(r.row("Date"))})

This makes sense because we don't know which query to base `r.row` on? Is it the
main query, or sub query?

Luckily, we can use function to solve this.

### Expression

Let's get some basic knowledge then we will come back to the previous example.

Beside passing an object into `update` command, we can also pass an expression which
returns an object. RethinkDB will evaluate it, get the object result and using
that value for `update` command. It comes in useful when you have some logic
on your document related to the updating. Example, if `views` is greater than
100, we set its type to *host*, otherwise, it's *normal*.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
        update(function(post) {
            return r.branch(
                post("views").gt(100),
                {type: "hot"},
                {type: "normal"}
            )
        })
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
    //=>
    {
        "Date": "May 2" ,
        "Day": 120 ,
        "Dem": 120 ,
        "New Value": 1 ,
        "authors": [
            "foo" ,
            "bar"
        ] ,
        "id": "foo-bar" ,
        "type": "normal" ,
        "uuid": "13556cd8-034c-4c0e-91c0-666230740121" ,
        "views": 100
    }

Don't care too much about `r.branch`. It's like an `IF` in MySQL. If the first
argument is TRUE, the second argument is return, otherwise the third.

When using a function, the parameter pass into function will be the current
visited document. Therefore, you can use many document manipulation command in
it such as: pluck, without, merge, append, prepend. Just remember this, so
you know what you can do with that parameter.

Now, back to our previous example.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update(function (poll) {
        return {
          same_day_count: r.table('input_polls')('Date').count(poll('Date'))
        }
      })

The query runs, but throw this error:

    RqlRuntimeError: Could not prove function deterministic.  Maybe you want to use the non_atomic flag? in:
    r.table("input_polls").get("13556cd8-034c-4c0e-91c0-666230740121").update(function(var_11) { return {same_day_count: r.table("input_polls")("Date").count(var_11("Date"))}; })

Well, this is because the updating isn't atomic. 

T > non-atomic updates 
T >    
T > They are updates that require fetching data from another document.

Let's make it atomic and try again:

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update(function (poll) {
        return {
          same_day_count: r.table('input_polls')('Date').count(poll('Date'))
        }
      }, {nonAtomic: true})
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }

    //Verify
    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
    //=>
    {

        "Date": "May 2" ,
        "Day": 120 ,
        "Dem": 120 ,
        "New Value": 1 ,
        "authors": [
            "foo" ,
            "bar"
        ] ,
        "id": "foo-bar" ,
        "reviewer": {
            "age": 25 ,
            "name": "Vinh" ,
            "state": "CA"
        } ,
        "same_day_count": 1 ,
        "type": "normal" ,
        "uuid": "13556cd8-034c-4c0e-91c0-666230740121" ,
        "views": 100

    }

#### Expr

`expr` is a normal function but I think they are important and will help us
achive many crazy things so I cover them here.

What `expr` does is tranform a native object from host language into ReQL
object. For example, if a RethinkDb funciton can be call on array or sequence,
we cannot write something like this: `[e1, e2].nth(2)`, RethinkDB will throw an
error on [e1, e2]

    ["e1","e2"].nth is not a function

What we have to do is somehow convert the array that we write in native
language into RethinkDB data type. To do that, we simply wrap them in `expr`

A real example when I'm writing this book is I want to randomize generate
faked data for `users` table on `gender` field. I do this with:

    r.db("foodb").table("users")
      .update({
        gender: r.expr(['m', 'f']).nth(r.random(0, 2))
      }, {nonAtomic: true})

It means that for every document of `users` table, I want to set their gender to
either `m` or `f` randomly. I create a two element array `[m, f]`, turn them
into ReQL object with `expr`, so that I can call `nth` on them, passing a random
number of either 0 or 1.


let's try a more complex example to generate some data. We want to r

    r.db("foodb").table("users")
      .update({
          eatenfoods: r.db("foodb").table("foods").sample(r.random(0,
10)).getField('name')
        },
        {nonAtomic: true}
      )

For every document, we try to find a number of random food from `foods` table,
get only its name and return the array, and assign to `eatfoods`

Now, we have `eatenfoods` field. Let's say we want to create a field contains
the foods that an user has eaten, and his or her most favourite foods (first element
in `favfoods` field)

    r.db("foodb").table("users")
      .update({
        eateanorlike : r.add(r.row("eatenfoods"), [r.row("favfoods").nth(0)])
      }, {nonAtomic: true})

By combine ReQL expression, looking at its API and find approriate function,
we can achieve what we want. In the above example, we know we want to concat two
arrays from `eatenfoods` and first item of `favfoods`. We used `r.add`. We have
to wrap `r.row("favfoods").nth(0)` in `[]` because `nth()` return a document,
where as `r.add` expects array, so we wrap it in `[]`.

Before we continue, let's remove junk data:

    r.db("foodb").table("users").replace(r.row.without('eateanorlike'))

We also didn't have an `age` field on those user table. Let's generate some fake
data for it so we can play around later

    r.db("foodb").table("users")
      .update({
        age : r.random(8, 90)
      }, {nonAtomic: true})
    #=>
    {
    "deleted": 0 ,
    "errors": 0 ,
    "inserted": 0 ,
    "replaced": 152 ,
    "skipped": 0 ,
    "unchanged": 0
    }

By using function or expression, we can update document in a complex way

### Return Values

Sometimes, it can be useful to get back the updated document. This way you can
verify the result, without issuing a sub sequent `get` command. We just need to
set `returnVals` flag to true in option parameter of `update` command. Same
example:

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update(function (poll) {
        return {
          same_day_count: r.table('input_polls')('Date').count(poll('Date'))
        }
      }, {nonAtomic: true, returnVals: true})
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "new_val": {
            "Date": "May 2" ,
            "Day": 120 ,
            "Dem": 120 ,
            "New Value": 1 ,
            "authors": [
                "foo" ,
                "bar"
            ] ,
            "id": "foo-bar" ,
            "reviewer": {
                "age": 25 ,
                "name": "Vinh" ,
                "state": "CA"
            } ,
            "same_day_count": 1 ,
            "type": "normal" ,
            "uuid": "13556cd8-034c-4c0e-91c0-666230740121" ,
            "views": 100
        } ,
        "old_val": {
            "Date": "May 2" ,
            "Day": 120 ,
            "Dem": 120 ,
            "New Value": 1 ,
            "authors": [
                "foo" ,
                "bar"
            ] ,
            "id": "foo-bar" ,
            "reviewer": {
                "age": 25 ,
                "name": "Vinh" ,
                "state": "CA"
            } ,
            "same_day_count": 1 ,
            "type": "normal" ,
            "uuid": "13556cd8-034c-4c0e-91c0-666230740121" ,
            "views": 100
        } ,
        "replaced": 0 ,
        "skipped": 0 ,
        "unchanged": 1
    }

The old value and value are returned in key `old_val` and `new_val`
correspondingly.

## Replace

To remove one or many fields from document, we cannot use `update` anymore.
We can set a field to `null` value(null, nil depends on your language) to make
it become null. But they key is still in the document with a `null` value.

We have to use `replace` method to replace it with a new document. The
new document is constructed from old document without the data we want to
eliminate.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .replace(r.row.without('lol_author'))
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }

We can replace an entirely new document. However, the primary key cannot be
updated. It has to be same with the current primary key. An attempt to change
the primary key will caused an error **Primary key `uuid` cannot be changed**


    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .replace({

        "Date": "May 2" ,
        "Day": 120 ,
        "Dem": 120 ,
        "New Value": 1 ,
        "authors": [
            "foo", "bar"
        ] ,
        "id": "foo-bar" ,
        "uuid": "13556cd8-034c-4c0e-91c0-666230740121" ,
        "views": 100
    })
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }



What if we want to remove an attribute of document? Well, let's set it to
`null`. Depend on your language, you have to use your null value such as in
Ruby, it's `nil`.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
          'Dem': null
      })
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0
    }


## Delete

Just go ahead and type those command if you want to. We can at any point, reset
to the original data set.

To remove one ore more document, use ReQL to select what we want and
execute `*delete*` on them.

This will delete a single document. 
    r.table('input_polls').get('id').delete()

Let clear out the vote from florda on may

    r.table('input_polls').filter(function (row) {
      r.row()
    })

Or just wipe an entire table

    r.table().delete()


`delete` method accepts an optional object with:

  * durability: 'hard' or 'soft'. default 'hard' and will override the value of
run.
  * returnVals: 'false' or true. True mean if the document fail to removed for
any reason, it will be returned to your result set. 

## Sync

As you known in the previous chapter, with value of `durability` as 'soft' the
write isn't guarantees to be written to the permanent storage. So after doing a
bunch of those `soft durability`, you may want to say `Hey, I am done all task,
let's make sure you write those change` you can call sync

  r.table('t').sync().run(connection, function () {
    console.log('Syncing is done. All data is safe now')
  })

A sync will run the callback will be called when all change are written to disk.
